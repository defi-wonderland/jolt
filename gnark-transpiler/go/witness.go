// Package jolt_verifier provides witness loading for Gnark circuits.
//
// This file loads JSON witness data generated by the Rust gnark-transpiler
// and converts it into the circuit assignment format needed by Gnark.
package jolt_verifier

import (
	"encoding/json"
	"fmt"
	"math/big"
	"os"

	"github.com/consensys/gnark/frontend"
)

// Stage1WitnessJSON represents the JSON structure from Rust
type Stage1WitnessJSON struct {
	Tau                 []string   `json:"tau"`
	R0                  string     `json:"r0"`
	SumcheckChallenges  []string   `json:"sumcheck_challenges"`
	UniSkipPolyCoeffs   []string   `json:"uni_skip_poly_coeffs"`
	SumcheckRoundPolys  [][]string `json:"sumcheck_round_polys"`
	ExpectedFinalClaim  string     `json:"expected_final_claim"`
}

// LoadWitnessFromJSON loads witness from a JSON file
func LoadWitnessFromJSON(path string) (*Stage1WitnessJSON, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var witness Stage1WitnessJSON
	if err := json.Unmarshal(data, &witness); err != nil {
		return nil, err
	}

	return &witness, nil
}

// ToFlatValues converts the witness to a flat list of big.Int values
// in the same order as the Rust side: tau, r0, sumcheck_challenges,
// uni_skip_poly_coeffs, sumcheck_round_polys flattened, expected_final_claim
func (w *Stage1WitnessJSON) ToFlatValues() ([]*big.Int, error) {
	var values []*big.Int

	// Parse tau
	for _, s := range w.Tau {
		v, ok := new(big.Int).SetString(s, 10)
		if !ok {
			return nil, fmt.Errorf("invalid tau value: %s", s)
		}
		values = append(values, v)
	}

	// Parse r0
	r0, ok := new(big.Int).SetString(w.R0, 10)
	if !ok {
		return nil, fmt.Errorf("invalid r0 value: %s", w.R0)
	}
	values = append(values, r0)

	// Parse sumcheck_challenges
	for _, s := range w.SumcheckChallenges {
		v, ok := new(big.Int).SetString(s, 10)
		if !ok {
			return nil, fmt.Errorf("invalid sumcheck challenge: %s", s)
		}
		values = append(values, v)
	}

	// Parse uni_skip_poly_coeffs
	for _, s := range w.UniSkipPolyCoeffs {
		v, ok := new(big.Int).SetString(s, 10)
		if !ok {
			return nil, fmt.Errorf("invalid uni skip coeff: %s", s)
		}
		values = append(values, v)
	}

	// Parse sumcheck_round_polys (flattened)
	for _, poly := range w.SumcheckRoundPolys {
		for _, s := range poly {
			v, ok := new(big.Int).SetString(s, 10)
			if !ok {
				return nil, fmt.Errorf("invalid sumcheck poly coeff: %s", s)
			}
			values = append(values, v)
		}
	}

	// Parse expected_final_claim
	finalClaim, ok := new(big.Int).SetString(w.ExpectedFinalClaim, 10)
	if !ok {
		return nil, fmt.Errorf("invalid expected final claim: %s", w.ExpectedFinalClaim)
	}
	values = append(values, finalClaim)

	return values, nil
}

// AssignToCircuit creates a circuit assignment from the witness
// This is a generic helper - the actual circuit struct must match
// the generated Go code from the transpiler.
func (w *Stage1WitnessJSON) AssignToCircuit(circuit interface{}) error {
	// This would need reflection or code generation to work generically
	// For now, use the specific circuit type from the generated code
	return nil
}

// StringToBigInt converts a decimal string to big.Int
func StringToBigInt(s string) (*big.Int, error) {
	v, ok := new(big.Int).SetString(s, 10)
	if !ok {
		return nil, fmt.Errorf("invalid number: %s", s)
	}
	return v, nil
}

// BigIntToVariable converts a big.Int to frontend.Variable
func BigIntToVariable(v *big.Int) frontend.Variable {
	return v
}
